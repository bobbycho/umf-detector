#include "shaders.h"

const char* shLineVertex = 
	"#ifdef GL_ES\n"
	"precision float lowp;\n"
	"#endif\n"
	"\n"
	"attribute vec3 pos;\n"
	"uniform mat4 mvp;\n"
	"\n"
	"void main(void){\n"
	"	gl_Position = mvp*pos;\n"
	"}\n"
	"";

const char* shLineFragment = 
	"#ifdef GL_ES\n"
	"precision float lowp;\n"
	"#endif\n"
	"\n"
	"uniform vec3 color;\n"
	"\n"
	"void main(void){\n"
	"	gl_FragColor = vec4(color,1.0);\n"
	"}\n"
	"";

const QuadVertex QuadFullScreen[] = {
    {{1, -1, 0.0}, {1, 0}},
    {{1, 1, 0.0}, {1, 1}},
    {{-1, 1, 0.0}, {0, 1}},
    {{-1, -1, 0.0}, {0, 0}}
};

const QuadVertex QuadReverseFullScreen[] = {
    {{1, -1, 0.01}, {1, 1}},
    {{1, 1, 0.01}, {1, 0}},
    {{-1, 1, 0.01}, {0, 0}},
    {{-1, -1, 0.01}, {0, 1}}
};

const char* shQuadVertex = 
	"#ifdef GL_ES\n"
	"precision lowp float;\n"
	"#endif\n"
	"\n"
	"attribute vec3 pos;\n"
	"attribute vec2 texCoord;\n"
	"varying vec2 vTexCoord;\n"
	"uniform mat4 mvp;\n"
	"\n"
	"void main(void){\n"
	"	gl_Position = mvp*vec4(pos,1.0);\n"
	"	vTexCoord = texCoord;\n"
	"}\n"
	"";

const char* shQuadFragment = 
	"#ifdef GL_ES\n"
	"precision lowp float;\n"
	"#endif\n"
	"\n"
	"uniform sampler2D texImg;\n"
	"varying vec2 vTexCoord;\n"
	"\n"
	"void main(void){\n"
	"	gl_FragColor = texture2D(texImg, vTexCoord);\n"
	"}\n"
	"";

const char* shQuadNV21FragmentGreen = 
	"#ifdef GL_ES\n"
	"precision lowp float;\n"
	"#endif\n"
	"\n"
	"uniform sampler2D texImgY;\n"
	"uniform sampler2D texImgUV;\n"
	"const mat3 yuv2rgb = mat3(\n"
    "                    1, 0, 1.2802,\n"
    "                    1, -0.214821, -0.380589,\n"
    "                   1, 2.127982, 0\n"
    "                    );\n"
	"varying vec2 vTexCoord;\n"
	"\n"
	"void main(void){\n"
	"	vec3 yuv = vec3(\n"
    "		         1.1643 * (texture2D(texImgY, vTexCoord).r - 0.0627),\n"
    "		         texture2D(texImgUV, vTexCoord).a - 0.5,\n"
    "		         texture2D(texImgUV, vTexCoord).r - 0.5\n"
    "		         );\n"
	"	float mask = smoothstep(0.1, 0.5, smoothstep(-0.05, 0.1, -yuv.z)*smoothstep(-0.05, 0.1, -yuv.y));\n"
    "	vec3 rgb = yuv * yuv2rgb;\n"
	"	gl_FragColor = vec4(rgb, 1.0 - mask);\n"
	"}\n"
	"";

const char* shQuadNV21Fragment = 
	"#ifdef GL_ES\n"
	"precision lowp float;\n"
	"#endif\n"
	"\n"
	"uniform sampler2D texImgY;\n"
	"uniform sampler2D texImgUV;\n"
	"const mat3 yuv2rgb = mat3(\n"
    "                    1, 0, 1.2802,\n"
    "                    1, -0.214821, -0.380589,\n"
    "                   1, 2.127982, 0\n"
    "                    );\n"
	"varying vec2 vTexCoord;\n"
	"\n"
	"void main(void){\n"
	"	vec3 yuv = vec3(\n"
    "		         1.1643 * (texture2D(texImgY, vTexCoord).r - 0.0627),\n"
    "		         texture2D(texImgUV, vTexCoord).a - 0.5,\n"
    "		         texture2D(texImgUV, vTexCoord).r - 0.5\n"
    "		         );\n"
    "	vec3 rgb = yuv * yuv2rgb;\n"
	"	gl_FragColor = vec4(rgb, 1.0);\n"
	"}\n"
	"";

const char* shQuadESExtTexFragment = 
	"#extension GL_OES_EGL_image_external : require\n"
	"precision mediump float;\n"
	"\n"
	"uniform samplerExternalOES texImg;\n"
	"uniform mat4 texMVP;\n"
	"varying vec2 vTexCoord;\n"
	"\n"
	"void main(void){\n"
	"	gl_FragColor = texture2D(texImg, (texMVP*vec4(vTexCoord, 0.0, 1.0)).xy);\n"
	"}\n"
	"";

const char* shQuadESExtTexFragmentGreen = 
	"#extension GL_OES_EGL_image_external : require\n"
	"precision mediump float;\n"
	"\n"
	"uniform samplerExternalOES texImg;\n"
	"uniform mat4 texMVP;\n"
	"varying vec2 vTexCoord;\n"
	"const mat3 rgb2yuv = mat3(\n"
    "                    0.257, 0.439, -0.148,\n"
    "                    0.504, -0.368, -0.291,\n"
    "                    0.098, -0.071, 0.439\n"
    "                    );\n"
    " //first lets rotate values by key color CbCr: 75 (-29), 90\n"
    " const float keyCb = 90.0/128.0 - 1.0;\n"
    " const float keyCr = 80.0/128.0 - 1.0;\n"
    " const float keyl = sqrt(keyCb*keyCb + keyCr*keyCr);//0.581\n"
    " //greeensreen, so we negate\n"
    " const float cosKey = keyCb/keyl;\n"
    " const float sinKey = keyCr/keyl;\n"
    " const mat2 xzRot = mat2( cosKey, -sinKey,\n"
    "                       sinKey, cosKey);\n"
    " const float angleThreshold = 1.0/5.0;//tan(75*);\n"
    " const float angleThreshold2 = 1.0/1.0;//tan(3.14/12.0);\n"
    " const float angleThresholdInv = 1.0/angleThreshold;\n"
    " const float angleThreshold2Inv = 1.0/angleThreshold2;\n"
	"\n"
	"void main(void){\n"
	"	vec4 color = texture2D(texImg, (texMVP*vec4(vTexCoord, 0.0, 1.0)).xy);\n"
    "	//float maskval = clamp((color.g - max(color.r, color.b))*8.0 - 0.3, 0.0, 1.0);\n"
	"   vec3 yuv = rgb2yuv*color.rgb;\n"
    "   vec2 xzColor = xzRot*yuv.yz;\n"
    "   //float mask = smoothstep(0.1, 0.5, smoothstep(-0.05, 0.1, -yuv.z)*smoothstep(-0.05, 0.1, -yuv.y));\n"
    "   float kfg = xzColor.x - abs(xzColor.y)*angleThreshold2Inv;\n"
    "   float mask = smoothstep(0.05, 0.2, kfg)*smoothstep(angleThreshold2Inv, angleThresholdInv, xzColor.x/abs(xzColor.y));\n"
	"	\n"
	"	gl_FragColor = vec4(color.rgb, 1.0 - mask);\n"
	"}\n"
	"";

const char* shQuadESExtTexFragmentGreen2 =
"#extension GL_OES_EGL_image_external : require\n"
"precision mediump float;\n"
"\n"
"uniform samplerExternalOES texImg;\n"
"uniform mat4 texMVP;\n"
"varying vec2 vTexCoord;\n"
"const mat3 rgb2yuv = mat3(\n"
"                    0.299, -0.1698935, 0.499813,\n"
"                    0.587, -0.331665, -0.418531,\n"
"                    0.114, 0.50059, -0.081282\n"
"                    );\n"
" //first lets rotate values by key color CbCr: 75 (-29), 90\n"
" const float keyCb1 = 99.0/128.0 - 1.0;\n"
" const float keyCr1 = 124.0/128.0 - 1.0;\n"
" const float keyCb2 = 104.0/128.0 - 1.0;\n"
" const float keyCr2 = 104.0/128.0 - 1.0;\n"
" const float keyCb3 = 109.0/128.0 - 1.0;\n"
" const float keyCr3 = 95.0/128.0 - 1.0;\n"
" const float keyl1 = sqrt(keyCb1*keyCb1 + keyCr1*keyCr1);//0.581\n"
" const float keyl2 = sqrt(keyCb2*keyCb2 + keyCr2*keyCr2);//0.581\n"
" const float keyl3 = sqrt(keyCb3*keyCb3 + keyCr3*keyCr3);//0.581\n"
" //greeensreen, so we negate\n"
" const float cosKey1 = keyCb1/keyl1;\n"
" const float sinKey1 = keyCr1/keyl1;\n"
" const float cosKey2 = keyCb2/keyl2;\n"
" const float sinKey2 = keyCr2/keyl2;\n"
" const float cosKey3 = keyCb3/keyl3;\n"
" const float sinKey3 = keyCr3/keyl3;\n"
" const mat2 xzRot1 = mat2( cosKey1, -sinKey1,\n"
"                       sinKey1, cosKey1);\n"
" const mat2 xzRot2 = mat2( cosKey2, -sinKey2,\n"
"                       sinKey2, cosKey2);\n"
" const mat2 xzRot3 = mat2( cosKey3, -sinKey3,\n"
"                       sinKey3, cosKey3);\n"
" const float angleThreshold = 0.2;//tan(10*);\n"
" const float angleThreshold2 = 0.8;//tan(25);\n"
" const float angleThresholdInv = 1.0/angleThreshold;\n"
" const float angleThreshold2Inv = 1.0/angleThreshold2;\n"
"\n"
"void main(void){\n"
"	vec4 color = texture2D(texImg, (texMVP*vec4(vTexCoord, 0.0, 1.0)).xy);\n"
"	//float maskval = clamp((color.g - max(color.r, color.b))*8.0 - 0.3, 0.0, 1.0);\n"
"   vec3 yuv = rgb2yuv*color.rgb;\n"
"   vec2 xzColor1 = xzRot1*(yuv.yz*4.0);\n"
"   vec2 xzColor2 = xzRot2*(yuv.yz*4.0);\n"
"   vec2 xzColor3 = xzRot3*(yuv.yz*4.0);\n"
"   //float mask = smoothstep(0.0, 0.05, smoothstep(-0.05, 0.1, -yuv.z)*smoothstep(-0.05, 0.1, -yuv.y));\n"
"   float kfg1 = xzColor1.x - abs(xzColor1.y)*angleThreshold2Inv;\n"
"   float kfg2 = xzColor2.x - abs(xzColor2.y)*angleThreshold2Inv;\n"
"   float kfg3 = xzColor3.x - abs(xzColor3.y)*angleThreshold2Inv;\n"
"   float mask1 = smoothstep(0.1, 0.4, kfg1);//*smoothstep(angleThreshold2Inv, angleThresholdInv, xzColor.x/abs(xzColor.y));\n"
"   float mask2 = smoothstep(0.1, 0.4, kfg2);//*smoothstep(angleThreshold2Inv, angleThresholdInv, xzColor.x/abs(xzColor.y));\n"
"   float mask3 = smoothstep(0.1, 0.4, kfg3);//*smoothstep(angleThreshold2Inv, angleThresholdInv, xzColor.x/abs(xzColor.y));\n"
"	\n"
"	gl_FragColor = vec4(color.rgb, 1.0 - max(mask1, max(mask2, mask3)) );\n"
"}\n"
"";